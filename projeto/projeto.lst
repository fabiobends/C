CCS PCH C Compiler, Version 5.070, 56587               20-jun-17 09:53

               Filename:   C:\Users\Fábio Bends\Documents\PIC\projeto\projeto.lst

               ROM used:   2652 bytes (8%)
                           Largest free fragment is 30112
               RAM used:   36 (2%) at main() level
                           87 (4%) worst case
               Stack used: 6 locations (4 in main + 2 for interrupts)
               Stack size: 31

*
0000:  GOTO   09AA
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.1
0056:  GOTO   0060
005A:  BTFSC  F9E.1
005C:  GOTO   01E8
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVFF  15,FF5
009A:  MOVFF  16,FF6
009E:  MOVFF  17,FF7
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... #include <projeto.h> 
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
00AE:  CLRF   4D
00B0:  CLRF   4E
00B2:  MOVLW  01
00B4:  MOVWF  4F
00B6:  CLRF   FDA
00B8:  CLRF   FD9
00BA:  CLRF   52
00BC:  MOVLW  45
00BE:  MOVWF  51
00C0:  CLRF   FEA
00C2:  MOVLW  49
00C4:  MOVWF  FE9
00C6:  MOVFF  52,FE2
00CA:  MOVFF  51,FE1
00CE:  MOVFF  4F,50
00D2:  BCF    FD8.0
00D4:  MOVF   FE5,W
00D6:  MULWF  FEE
00D8:  MOVF   FF3,W
00DA:  ADDWFC 4D,F
00DC:  MOVF   FF4,W
00DE:  ADDWFC 4E,F
00E0:  DECFSZ 50,F
00E2:  BRA    00D2
00E4:  MOVFF  4D,FDE
00E8:  MOVFF  4E,4D
00EC:  CLRF   4E
00EE:  BTFSC  FD8.0
00F0:  INCF   4E,F
00F2:  INCF   51,F
00F4:  BTFSC  FD8.2
00F6:  INCF   52,F
00F8:  INCF   4F,F
00FA:  MOVF   4F,W
00FC:  SUBLW  05
00FE:  BNZ   00C0
0100:  GOTO   023C (RETURN)
0104:  BTFSC  FD8.1
0106:  BRA    010E
0108:  CLRF   FEA
010A:  MOVLW  51
010C:  MOVWF  FE9
010E:  MOVF   4C,W
0110:  XORWF  50,W
0112:  ANDLW  80
0114:  MOVWF  56
0116:  BTFSS  4C.7
0118:  BRA    0130
011A:  COMF   49,F
011C:  COMF   4A,F
011E:  COMF   4B,F
0120:  COMF   4C,F
0122:  INCF   49,F
0124:  BTFSC  FD8.2
0126:  INCF   4A,F
0128:  BTFSC  FD8.2
012A:  INCF   4B,F
012C:  BTFSC  FD8.2
012E:  INCF   4C,F
0130:  BTFSS  50.7
0132:  BRA    014A
0134:  COMF   4D,F
0136:  COMF   4E,F
0138:  COMF   4F,F
013A:  COMF   50,F
013C:  INCF   4D,F
013E:  BTFSC  FD8.2
0140:  INCF   4E,F
0142:  BTFSC  FD8.2
0144:  INCF   4F,F
0146:  BTFSC  FD8.2
0148:  INCF   50,F
014A:  CLRF   00
014C:  CLRF   01
014E:  CLRF   02
0150:  CLRF   03
0152:  CLRF   51
0154:  CLRF   52
0156:  CLRF   53
0158:  CLRF   54
015A:  MOVF   50,W
015C:  IORWF  4F,W
015E:  IORWF  4E,W
0160:  IORWF  4D,W
0162:  BZ    01BC
0164:  MOVLW  20
0166:  MOVWF  55
0168:  BCF    FD8.0
016A:  RLCF   49,F
016C:  RLCF   4A,F
016E:  RLCF   4B,F
0170:  RLCF   4C,F
0172:  RLCF   51,F
0174:  RLCF   52,F
0176:  RLCF   53,F
0178:  RLCF   54,F
017A:  MOVF   50,W
017C:  SUBWF  54,W
017E:  BNZ   0190
0180:  MOVF   4F,W
0182:  SUBWF  53,W
0184:  BNZ   0190
0186:  MOVF   4E,W
0188:  SUBWF  52,W
018A:  BNZ   0190
018C:  MOVF   4D,W
018E:  SUBWF  51,W
0190:  BNC   01B0
0192:  MOVF   4D,W
0194:  SUBWF  51,F
0196:  MOVF   4E,W
0198:  BTFSS  FD8.0
019A:  INCFSZ 4E,W
019C:  SUBWF  52,F
019E:  MOVF   4F,W
01A0:  BTFSS  FD8.0
01A2:  INCFSZ 4F,W
01A4:  SUBWF  53,F
01A6:  MOVF   50,W
01A8:  BTFSS  FD8.0
01AA:  INCFSZ 50,W
01AC:  SUBWF  54,F
01AE:  BSF    FD8.0
01B0:  RLCF   00,F
01B2:  RLCF   01,F
01B4:  RLCF   02,F
01B6:  RLCF   03,F
01B8:  DECFSZ 55,F
01BA:  BRA    0168
01BC:  BTFSS  56.7
01BE:  BRA    01D6
01C0:  COMF   00,F
01C2:  COMF   01,F
01C4:  COMF   02,F
01C6:  COMF   03,F
01C8:  INCF   00,F
01CA:  BTFSC  FD8.2
01CC:  INCF   01,F
01CE:  BTFSC  FD8.2
01D0:  INCF   02,F
01D2:  BTFSC  FD8.2
01D4:  INCF   03,F
01D6:  MOVFF  51,FEF
01DA:  MOVFF  52,FEC
01DE:  MOVFF  53,FEC
01E2:  MOVFF  54,FEC
01E6:  RETURN 0
*
03AC:  CLRF   00
03AE:  CLRF   01
03B0:  MOVF   3E,W
03B2:  BCF    FD8.0
03B4:  BTFSC  3F.0
03B6:  ADDWF  00,F
03B8:  RRCF   00,F
03BA:  RRCF   01,F
03BC:  BTFSC  3F.1
03BE:  ADDWF  00,F
03C0:  RRCF   00,F
03C2:  RRCF   01,F
03C4:  BTFSC  3F.2
03C6:  ADDWF  00,F
03C8:  RRCF   00,F
03CA:  RRCF   01,F
03CC:  BTFSC  3F.3
03CE:  ADDWF  00,F
03D0:  RRCF   00,F
03D2:  RRCF   01,F
03D4:  BTFSC  3F.4
03D6:  ADDWF  00,F
03D8:  RRCF   00,F
03DA:  RRCF   01,F
03DC:  BTFSC  3F.5
03DE:  ADDWF  00,F
03E0:  RRCF   00,F
03E2:  RRCF   01,F
03E4:  BTFSC  3F.6
03E6:  ADDWF  00,F
03E8:  RRCF   00,F
03EA:  RRCF   01,F
03EC:  BTFSC  3F.7
03EE:  ADDWF  00,F
03F0:  RRCF   00,F
03F2:  RRCF   01,F
03F4:  RETURN 0
....................  
.................... #list 
....................  
.................... #device ADC=10 
.................... #use delay(clock=20MHz,crystal=20MHz) 
....................  
....................  
.................... #include <glcd.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                           GLCD.C                                //// 
.................... ////                                                                 //// 
.................... //// This file contains drivers for using a Hantronix HDM64GS12 with //// 
.................... //// an LED backlight. The HDM64GS12 is 128 pixles across and 64     //// 
.................... //// pixels down. The driver treats the upper left pixel as (0,0).   //// 
.................... ////                                                                 //// 
.................... //// LCD Pin connections:                                            //// 
.................... //// (These can be changed as needed in the following defines).      //// 
.................... ////  * 1: VSS is connected to GND                                   //// 
.................... ////  * 2: VDD is connected to +5V                                   //// 
.................... ////  * 3: V0 - LCD operating voltage is connected from a 20k Ohm POT//// 
.................... ////  * 4: D/I - Data or Instruction is connected to B2              //// 
.................... ////  * 5: R/W - Read or Write is connected to B4                    //// 
.................... ////  * 6: Enable is connected to B5                                 //// 
.................... ////  *7-14: Data Bus 0 to 7 is connected to port d                  //// 
.................... ////  *15: Chip Select 1 is connected to B0                          //// 
.................... ////  *16: Chip Select 2 is connected to B1                          //// 
.................... ////  *17: Reset is connected to C0                                  //// 
.................... ////  *18: Negative voltage is also connected to the 20k Ohm POT     //// 
.................... ////  *19: Positive voltage for LED backlight is connected to +5V    //// 
.................... ////  *20: Negavtive voltage for LED backlight is connected to GND   //// 
.................... ////                                                                 //// 
.................... ////  glcd_init(mode)                                                //// 
.................... ////     * Must be called before any other function.                 //// 
.................... ////       - mode can be ON or OFF to turn the LCD on or off         //// 
.................... ////                                                                 //// 
.................... ////  glcd_pixel(x,y,color)                                          //// 
.................... ////     * Sets the pixel to the given color.                        //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_line(x1,y1,x2,y2,color)                                   //// 
.................... ////     * Draws a line from the first point to the second point     //// 
.................... ////       with the given color.                                     //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_rect(x1,y1,x2,y2,fill,color)                              //// 
.................... ////     * Draws a rectangle with upper left point (x1,y1) and lower //// 
.................... ////       right point (x2,y2).                                      //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_bar(x1,y1,x2,y2,width,color)                              //// 
.................... ////     * Draws a bar (wide line) from the first point to the       //// 
.................... ////       second point.                                             //// 
.................... ////       - width is the number of pixels wide                      //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_circle(x,y,radius,fill,color)                             //// 
.................... ////     * Draws a circle with center at (x,y)                       //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_text57(x,y,textptr,size,color)                            //// 
.................... ////     * Write the null terminated text pointed to by textptr with //// 
.................... ////       the upper left coordinate of the first character at (x,y).//// 
.................... ////       Characters are 5 pixels wide and 7 pixels tall.           //// 
.................... ////       - size is an integer that scales the size of the text     //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////     * Note - The given text is character wrapped. If this       //// 
.................... ////       function is used on a different size display, then change //// 
.................... ////       the GLCD_WIDTH define appropriately.                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_fillScreen(color)                                         //// 
.................... ////     * Fills the entire LCD with the given color.                //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #ifndef GLCD_C 
.................... #define GLCD_C 
....................  
.................... #ifndef GLCD_WIDTH 
.................... #define GLCD_WIDTH 128    // Used for text wrapping by glcd_text57 function 
.................... #endif 
....................  
.................... #define ON  1 
.................... #define OFF 0 
....................  
.................... #define YES 1 
.................... #define NO  0 
....................  
.................... #ifndef GLCD_CS1 
.................... #define GLCD_CS1 PIN_B0   // Chip Selection 1 
.................... #endif 
....................  
.................... #ifndef GLCD_CS2 
.................... #define GLCD_CS2 PIN_B1   // Chip Selection 2 
.................... #endif 
....................  
.................... #ifndef GLCD_DI 
.................... #define GLCD_DI  PIN_B2   // Data or Instruction input 
.................... #endif 
....................  
.................... #ifndef GLCD_RW 
.................... #define GLCD_RW  PIN_B4   // Read/Write 
.................... #endif 
....................  
.................... #ifndef GLCD_E 
.................... #define GLCD_E   PIN_B5   // Enable 
.................... #endif 
....................  
.................... #ifndef GLCD_RST 
.................... #define GLCD_RST PIN_C0   // Reset 
.................... #endif 
....................  
....................  
....................  
.................... BYTE glcd_readByte(BYTE chip); 
.................... void glcd_writeByte(BYTE chip, BYTE data); 
.................... void glcd_fillScreen(int1 color); 
....................  
.................... const BYTE TEXT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE 
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // ! 
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // " 
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // # 
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $ 
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // % 
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // & 
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // ' 
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // ( 
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // ) 
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // * 
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // + 
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // , 
....................                          0x08, 0x08, 0x08, 0x08, 0x08, // - 
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // . 
....................                          0x20, 0x10, 0x08, 0x04, 0x02, // / 
....................                          0x3E, 0x51, 0x49, 0x45, 0x3E, // 0 
....................                          0x04, 0x02, 0x7F, 0x00, 0x00, // 1 
....................                          0x42, 0x61, 0x51, 0x49, 0x46, // 2 
....................                          0x22, 0x41, 0x49, 0x49, 0x36, // 3 
....................                          0x18, 0x14, 0x12, 0x7F, 0x10, // 4 
....................                          0x27, 0x45, 0x45, 0x45, 0x39, // 5 
....................                          0x3E, 0x49, 0x49, 0x49, 0x32, // 6 
....................                          0x01, 0x01, 0x71, 0x09, 0x07, // 7 
....................                          0x36, 0x49, 0x49, 0x49, 0x36, // 8 
....................                          0x26, 0x49, 0x49, 0x49, 0x3E, // 9 
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // : 
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ; 
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // < 
....................                          0x14, 0x14, 0x14, 0x14, 0x14, // = 
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // > 
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ? 
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @ 
....................                          0x7E, 0x09, 0x09, 0x09, 0x7E, // A 
....................                          0x7F, 0x49, 0x49, 0x49, 0x36, // B 
....................                          0x3E, 0x41, 0x41, 0x41, 0x22, // C 
....................                          0x7F, 0x41, 0x41, 0x41, 0x3E, // D 
....................                          0x7F, 0x49, 0x49, 0x49, 0x41, // E 
....................                          0x7F, 0x09, 0x09, 0x09, 0x01, // F 
....................                          0x3E, 0x41, 0x41, 0x49, 0x3A, // G 
....................                          0x7F, 0x08, 0x08, 0x08, 0x7F, // H 
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I 
....................                          0x30, 0x40, 0x40, 0x40, 0x3F, // J 
....................                          0x7F, 0x08, 0x14, 0x22, 0x41, // K 
....................                          0x7F, 0x40, 0x40, 0x40, 0x40, // L 
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M 
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N 
....................                          0x3E, 0x41, 0x41, 0x41, 0x3E, // O 
....................                          0x7F, 0x09, 0x09, 0x09, 0x06, // P 
....................                          0x1E, 0x21, 0x21, 0x21, 0x5E, // Q 
....................                          0x7F, 0x09, 0x09, 0x09, 0x76};// R 
....................  
.................... const BYTE TEXT2[44][5]={0x26, 0x49, 0x49, 0x49, 0x32, // S 
....................                          0x01, 0x01, 0x7F, 0x01, 0x01, // T 
....................                          0x3F, 0x40, 0x40, 0x40, 0x3F, // U 
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V 
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W 
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X 
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y 
....................                          0x61, 0x51, 0x49, 0x45, 0x43, // Z 
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [ 
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \ 
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ] 
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^ 
....................                          0x40, 0x40, 0x40, 0x40, 0x40, // _ 
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // ` 
....................                          0x20, 0x54, 0x54, 0x54, 0x78, // a 
....................                          0x7F, 0x44, 0x44, 0x44, 0x38, // b 
....................                          0x38, 0x44, 0x44, 0x44, 0x44, // c 
....................                          0x38, 0x44, 0x44, 0x44, 0x7F, // d 
....................                          0x38, 0x54, 0x54, 0x54, 0x18, // e 
....................                          0x04, 0x04, 0x7E, 0x05, 0x05, // f 
....................                          0x08, 0x54, 0x54, 0x54, 0x3C, // g 
....................                          0x7F, 0x08, 0x04, 0x04, 0x78, // h 
....................                          0x00, 0x44, 0x7D, 0x40, 0x00, // i 
....................                          0x20, 0x40, 0x44, 0x3D, 0x00, // j 
....................                          0x7F, 0x10, 0x28, 0x44, 0x00, // k 
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l 
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m 
....................                          0x7C, 0x08, 0x04, 0x04, 0x78, // n 
....................                          0x38, 0x44, 0x44, 0x44, 0x38, // o 
....................                          0x7C, 0x14, 0x14, 0x14, 0x08, // p 
....................                          0x08, 0x14, 0x14, 0x14, 0x7C, // q 
....................                          0x00, 0x7C, 0x08, 0x04, 0x04, // r 
....................                          0x48, 0x54, 0x54, 0x54, 0x20, // s 
....................                          0x04, 0x04, 0x3F, 0x44, 0x44, // t 
....................                          0x3C, 0x40, 0x40, 0x20, 0x7C, // u 
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v 
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w 
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x 
....................                          0x0C, 0x50, 0x50, 0x50, 0x3C, // y 
....................                          0x44, 0x64, 0x54, 0x4C, 0x44, // z 
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // { 
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // | 
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // } 
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~ 
....................  
....................  
.................... // Purpose:       Initialize a graphic LCD. This must be called before any 
.................... //                other glcd function is used. 
.................... // Inputs:        The initialization mode 
.................... //                OFF - Turns the LCD off 
.................... //                ON  - Turns the LCD on 
.................... // Date:          5/28/2003 
.................... void glcd_init(int1 mode) 
.................... { 
....................    // Initialze some pins 
....................    output_high(GLCD_RST); 
*
0326:  BCF    F94.0
0328:  BSF    F8B.0
....................    output_low(GLCD_E); 
032A:  BCF    F93.5
032C:  BCF    F8A.5
....................    output_low(GLCD_CS1); 
032E:  BCF    F93.0
0330:  BCF    F8A.0
....................    output_low(GLCD_CS2); 
0332:  BCF    F93.1
0334:  BCF    F8A.1
....................  
....................    output_low(GLCD_DI);                // Set for instruction 
0336:  BCF    F93.2
0338:  BCF    F8A.2
....................    glcd_writeByte(GLCD_CS1, 0xC0);     // Specify first RAM line at the top 
033A:  MOVLW  08
033C:  MOVWF  43
033E:  MOVLW  C0
0340:  MOVWF  44
0342:  RCALL  0280
....................    glcd_writeByte(GLCD_CS2, 0xC0);     //   of the screen 
0344:  MOVLW  09
0346:  MOVWF  43
0348:  MOVLW  C0
034A:  MOVWF  44
034C:  RCALL  0280
....................    glcd_writeByte(GLCD_CS1, 0x40);     // Set the column address to 0 
034E:  MOVLW  08
0350:  MOVWF  43
0352:  MOVLW  40
0354:  MOVWF  44
0356:  RCALL  0280
....................    glcd_writeByte(GLCD_CS2, 0x40); 
0358:  MOVLW  09
035A:  MOVWF  43
035C:  MOVLW  40
035E:  MOVWF  44
0360:  RCALL  0280
....................    glcd_writeByte(GLCD_CS1, 0xB8);     // Set the page address to 0 
0362:  MOVLW  08
0364:  MOVWF  43
0366:  MOVLW  B8
0368:  MOVWF  44
036A:  RCALL  0280
....................    glcd_writeByte(GLCD_CS2, 0xB8); 
036C:  MOVLW  09
036E:  MOVWF  43
0370:  MOVLW  B8
0372:  MOVWF  44
0374:  RCALL  0280
....................    if(mode == ON) 
0376:  DECFSZ 24,W
0378:  BRA    0390
....................    { 
....................       glcd_writeByte(GLCD_CS1, 0x3F);  // Turn the display on 
037A:  MOVLW  08
037C:  MOVWF  43
037E:  MOVLW  3F
0380:  MOVWF  44
0382:  RCALL  0280
....................       glcd_writeByte(GLCD_CS2, 0x3F); 
0384:  MOVLW  09
0386:  MOVWF  43
0388:  MOVLW  3F
038A:  MOVWF  44
038C:  RCALL  0280
....................    } 
038E:  BRA    03A4
....................    else 
....................    { 
....................       glcd_writeByte(GLCD_CS1, 0x3E);  // Turn the display off 
0390:  MOVLW  08
0392:  MOVWF  43
0394:  MOVLW  3E
0396:  MOVWF  44
0398:  RCALL  0280
....................       glcd_writeByte(GLCD_CS2, 0x3E); 
039A:  MOVLW  09
039C:  MOVWF  43
039E:  MOVLW  3E
03A0:  MOVWF  44
03A2:  RCALL  0280
....................    } 
....................  
....................    glcd_fillScreen(OFF);               // Clear the display 
03A4:  CLRF   27
03A6:  RCALL  02B4
03A8:  GOTO   0A00 (RETURN)
.................... } 
....................  
....................  
.................... // Purpose:       Turn a pixel on a graphic LCD on or off 
.................... // Inputs:        x - the x coordinate of the pixel 
.................... //                y - the y coordinate of the pixel 
.................... //                color - ON or OFF 
.................... // Output:        1 if coordinate out of range, 0 if in range 
.................... void glcd_pixel(int x, int y, int1 color) 
*
044A:  MOVLW  08
044C:  MOVWF  41
.................... { 
....................    BYTE data; 
....................    BYTE chip = GLCD_CS1;  // Stores which chip to use on the LCD 
....................  
....................    if(x > 63)  // Check for first or second display area 
044E:  MOVF   3D,W
0450:  SUBLW  3F
0452:  BC    045C
....................    { 
....................       x -= 64; 
0454:  MOVLW  40
0456:  SUBWF  3D,F
....................       chip = GLCD_CS2; 
0458:  MOVLW  09
045A:  MOVWF  41
....................    } 
....................  
....................    output_low(GLCD_DI);                                     // Set for instruction 
045C:  BCF    F93.2
045E:  BCF    F8A.2
....................    bit_clear(x,7);                                          // Clear the MSB. Part of an instruction code 
0460:  BCF    3D.7
....................    bit_set(x,6);                                            // Set bit 6. Also part of an instruction code 
0462:  BSF    3D.6
....................    glcd_writeByte(chip, x);                                 // Set the horizontal address 
0464:  MOVFF  41,43
0468:  MOVFF  3D,44
046C:  RCALL  0280
....................    glcd_writeByte(chip, (y/8 & 0b10111111) | 0b10111000);   // Set the vertical page address 
046E:  RRCF   3E,W
0470:  MOVWF  00
0472:  RRCF   00,F
0474:  RRCF   00,F
0476:  MOVLW  1F
0478:  ANDWF  00,F
047A:  MOVF   00,W
047C:  ANDLW  BF
047E:  IORLW  B8
0480:  MOVWF  42
0482:  MOVFF  41,43
0486:  MOVWF  44
0488:  RCALL  0280
....................    output_high(GLCD_DI);                                    // Set for data 
048A:  BCF    F93.2
048C:  BSF    F8A.2
....................    data = glcd_readByte(chip); 
048E:  MOVFF  41,42
0492:  BRA    03F6
0494:  MOVFF  01,40
....................  
....................    if(color == ON) 
0498:  DECFSZ 3F,W
049A:  BRA    04BA
....................       bit_set(data, y%8);        // Turn the pixel on 
049C:  MOVF   3E,W
049E:  ANDLW  07
04A0:  MOVWF  42
04A2:  MOVLW  01
04A4:  MOVWF  00
04A6:  MOVF   42,W
04A8:  MOVWF  01
04AA:  BZ    04B4
04AC:  BCF    FD8.0
04AE:  RLCF   00,F
04B0:  DECFSZ 01,F
04B2:  BRA    04AC
04B4:  MOVF   00,W
04B6:  IORWF  40,F
04B8:  BRA    04D8
....................    else                          // or 
....................       bit_clear(data, y%8);      // turn the pixel off 
04BA:  MOVF   3E,W
04BC:  ANDLW  07
04BE:  MOVWF  42
04C0:  MOVLW  01
04C2:  MOVWF  00
04C4:  MOVF   42,W
04C6:  MOVWF  01
04C8:  BZ    04D2
04CA:  BCF    FD8.0
04CC:  RLCF   00,F
04CE:  DECFSZ 01,F
04D0:  BRA    04CA
04D2:  MOVF   00,W
04D4:  XORLW  FF
04D6:  ANDWF  40,F
....................    output_low(GLCD_DI);          // Set for instruction 
04D8:  BCF    F93.2
04DA:  BCF    F8A.2
....................    glcd_writeByte(chip, x);      // Set the horizontal address 
04DC:  MOVFF  41,43
04E0:  MOVFF  3D,44
04E4:  RCALL  0280
....................    output_high(GLCD_DI);         // Set for data 
04E6:  BCF    F93.2
04E8:  BSF    F8A.2
....................    glcd_writeByte(chip, data);   // Write the pixel data 
04EA:  MOVFF  41,43
04EE:  MOVFF  40,44
04F2:  RCALL  0280
04F4:  RETURN 0
.................... } 
....................  
....................  
.................... // Purpose:       Draw a line on a graphic LCD using Bresenham's 
.................... //                line drawing algorithm 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel() 
.................... void glcd_line(int x1, int y1, int x2, int y2, int1 color) 
.................... { 
....................    signed int  x, y, addx, addy, dx, dy; 
....................    signed long P; 
....................    int i; 
....................    dx = abs((signed int)(x2 - x1)); 
04F6:  MOVF   2F,W
04F8:  SUBWF  31,W
04FA:  MOVWF  3D
04FC:  MOVF   3D,W
04FE:  BTFSS  3D.7
0500:  BRA    0508
0502:  MOVLW  00
0504:  BSF    FD8.0
0506:  SUBFWB 3D,W
0508:  MOVWF  38
....................    dy = abs((signed int)(y2 - y1)); 
050A:  MOVF   30,W
050C:  SUBWF  32,W
050E:  MOVWF  3D
0510:  MOVF   3D,W
0512:  BTFSS  3D.7
0514:  BRA    051C
0516:  MOVLW  00
0518:  BSF    FD8.0
051A:  SUBFWB 3D,W
051C:  MOVWF  39
....................    x = x1; 
051E:  MOVFF  2F,34
....................    y = y1; 
0522:  MOVFF  30,35
....................  
....................    if(x1 > x2) 
0526:  MOVF   2F,W
0528:  SUBWF  31,W
052A:  BC    0530
....................       addx = -1; 
052C:  SETF   36
052E:  BRA    0534
....................    else 
....................       addx = 1; 
0530:  MOVLW  01
0532:  MOVWF  36
....................    if(y1 > y2) 
0534:  MOVF   30,W
0536:  SUBWF  32,W
0538:  BC    053E
....................       addy = -1; 
053A:  SETF   37
053C:  BRA    0542
....................    else 
....................       addy = 1; 
053E:  MOVLW  01
0540:  MOVWF  37
....................  
....................    if(dx >= dy) 
0542:  MOVF   39,W
0544:  XORLW  80
0546:  MOVWF  00
0548:  MOVF   38,W
054A:  XORLW  80
054C:  SUBWF  00,W
054E:  BZ    0552
0550:  BC    05DE
....................    { 
....................       P = 2*dy - dx; 
0552:  MOVLW  02
0554:  MOVWF  3E
0556:  MOVFF  39,3F
055A:  RCALL  03AC
055C:  MOVF   38,W
055E:  SUBWF  01,W
0560:  CLRF   03
0562:  BTFSC  FE8.7
0564:  DECF   03,F
0566:  MOVWF  3A
0568:  MOVFF  03,3B
....................  
....................       for(i=0; i<=dx; ++i) 
056C:  CLRF   3C
056E:  BTFSC  38.7
0570:  BRA    05DC
0572:  MOVF   3C,W
0574:  SUBWF  38,W
0576:  BNC   05DC
....................       { 
....................          glcd_pixel(x, y, color); 
0578:  MOVFF  34,3D
057C:  MOVFF  35,3E
0580:  MOVFF  33,3F
0584:  RCALL  044A
....................  
....................          if(P < 0) 
0586:  BTFSS  3B.7
0588:  BRA    05A8
....................          { 
....................             P += 2*dy; 
058A:  MOVLW  02
058C:  MOVWF  3E
058E:  MOVFF  39,3F
0592:  RCALL  03AC
0594:  MOVF   01,W
0596:  CLRF   03
0598:  BTFSC  FE8.7
059A:  DECF   03,F
059C:  ADDWF  3A,F
059E:  MOVF   03,W
05A0:  ADDWFC 3B,F
....................             x += addx; 
05A2:  MOVF   36,W
05A4:  ADDWF  34,F
....................          } 
05A6:  BRA    05D8
....................          else 
....................          { 
....................             P += 2*dy - 2*dx; 
05A8:  MOVLW  02
05AA:  MOVWF  3E
05AC:  MOVFF  39,3F
05B0:  RCALL  03AC
05B2:  MOVFF  01,3D
05B6:  MOVLW  02
05B8:  MOVWF  3E
05BA:  MOVFF  38,3F
05BE:  RCALL  03AC
05C0:  MOVF   01,W
05C2:  SUBWF  3D,W
05C4:  CLRF   03
05C6:  BTFSC  FE8.7
05C8:  DECF   03,F
05CA:  ADDWF  3A,F
05CC:  MOVF   03,W
05CE:  ADDWFC 3B,F
....................             x += addx; 
05D0:  MOVF   36,W
05D2:  ADDWF  34,F
....................             y += addy; 
05D4:  MOVF   37,W
05D6:  ADDWF  35,F
....................          } 
05D8:  INCF   3C,F
05DA:  BRA    056E
....................       } 
....................    } 
05DC:  BRA    0668
....................    else 
....................    { 
....................       P = 2*dx - dy; 
05DE:  MOVLW  02
05E0:  MOVWF  3E
05E2:  MOVFF  38,3F
05E6:  RCALL  03AC
05E8:  MOVF   39,W
05EA:  SUBWF  01,W
05EC:  CLRF   03
05EE:  BTFSC  FE8.7
05F0:  DECF   03,F
05F2:  MOVWF  3A
05F4:  MOVFF  03,3B
....................  
....................       for(i=0; i<=dy; ++i) 
05F8:  CLRF   3C
05FA:  BTFSC  39.7
05FC:  BRA    0668
05FE:  MOVF   3C,W
0600:  SUBWF  39,W
0602:  BNC   0668
....................       { 
....................          glcd_pixel(x, y, color); 
0604:  MOVFF  34,3D
0608:  MOVFF  35,3E
060C:  MOVFF  33,3F
0610:  RCALL  044A
....................  
....................          if(P < 0) 
0612:  BTFSS  3B.7
0614:  BRA    0634
....................          { 
....................             P += 2*dx; 
0616:  MOVLW  02
0618:  MOVWF  3E
061A:  MOVFF  38,3F
061E:  RCALL  03AC
0620:  MOVF   01,W
0622:  CLRF   03
0624:  BTFSC  FE8.7
0626:  DECF   03,F
0628:  ADDWF  3A,F
062A:  MOVF   03,W
062C:  ADDWFC 3B,F
....................             y += addy; 
062E:  MOVF   37,W
0630:  ADDWF  35,F
....................          } 
0632:  BRA    0664
....................          else 
....................          { 
....................             P += 2*dx - 2*dy; 
0634:  MOVLW  02
0636:  MOVWF  3E
0638:  MOVFF  38,3F
063C:  RCALL  03AC
063E:  MOVFF  01,3D
0642:  MOVLW  02
0644:  MOVWF  3E
0646:  MOVFF  39,3F
064A:  RCALL  03AC
064C:  MOVF   01,W
064E:  SUBWF  3D,W
0650:  CLRF   03
0652:  BTFSC  FE8.7
0654:  DECF   03,F
0656:  ADDWF  3A,F
0658:  MOVF   03,W
065A:  ADDWFC 3B,F
....................             x += addx; 
065C:  MOVF   36,W
065E:  ADDWF  34,F
....................             y += addy; 
0660:  MOVF   37,W
0662:  ADDWF  35,F
....................          } 
0664:  INCF   3C,F
0666:  BRA    05FA
....................       } 
....................    } 
0668:  RETURN 0
.................... } 
....................  
....................  
.................... // Purpose:       Draw a rectangle on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                fill  - YES or NO 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel(), glcd_line() 
.................... void glcd_rect(int x1, int y1, int x2, int y2, int fill, int1 color) 
.................... { 
....................    if(fill) 
066A:  MOVF   2B,F
066C:  BZ    06A8
....................    { 
....................       int y, ymax;                          // Find the y min and max 
....................       if(y1 < y2) 
066E:  MOVF   2A,W
0670:  SUBWF  28,W
0672:  BC    067E
....................       { 
....................          y = y1; 
0674:  MOVFF  28,2D
....................          ymax = y2; 
0678:  MOVFF  2A,2E
....................       } 
067C:  BRA    0686
....................       else 
....................       { 
....................          y = y2; 
067E:  MOVFF  2A,2D
....................          ymax = y1; 
0682:  MOVFF  28,2E
....................       } 
....................  
....................       for(; y<=ymax; ++y)                    // Draw lines to fill the rectangle 
0686:  MOVF   2D,W
0688:  SUBWF  2E,W
068A:  BNC   06A6
....................          glcd_line(x1, y, x2, y, color); 
068C:  MOVFF  27,2F
0690:  MOVFF  2D,30
0694:  MOVFF  29,31
0698:  MOVFF  2D,32
069C:  MOVFF  2C,33
06A0:  RCALL  04F6
06A2:  INCF   2D,F
06A4:  BRA    0686
....................    } 
06A6:  BRA    0700
....................    else 
....................    { 
....................       glcd_line(x1, y1, x2, y1, color);      // Draw the 4 sides 
06A8:  MOVFF  27,2F
06AC:  MOVFF  28,30
06B0:  MOVFF  29,31
06B4:  MOVFF  28,32
06B8:  MOVFF  2C,33
06BC:  RCALL  04F6
....................       glcd_line(x1, y2, x2, y2, color); 
06BE:  MOVFF  27,2F
06C2:  MOVFF  2A,30
06C6:  MOVFF  29,31
06CA:  MOVFF  2A,32
06CE:  MOVFF  2C,33
06D2:  RCALL  04F6
....................       glcd_line(x1, y1, x1, y2, color); 
06D4:  MOVFF  27,2F
06D8:  MOVFF  28,30
06DC:  MOVFF  27,31
06E0:  MOVFF  2A,32
06E4:  MOVFF  2C,33
06E8:  RCALL  04F6
....................       glcd_line(x2, y1, x2, y2, color); 
06EA:  MOVFF  29,2F
06EE:  MOVFF  28,30
06F2:  MOVFF  29,31
06F6:  MOVFF  2A,32
06FA:  MOVFF  2C,33
06FE:  RCALL  04F6
....................    } 
0700:  GOTO   071E (RETURN)
.................... } 
....................  
....................  
.................... // Purpose:       Draw a bar (wide line) on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                width  - The number of pixels wide 
.................... //                color - ON or OFF 
.................... void glcd_bar(int x1, int y1, int x2, int y2, int width, int1 color) 
.................... { 
....................    signed int  x, y, addx, addy, j; 
....................    signed long P, dx, dy, c1, c2; 
....................    int i; 
....................    dx = abs((signed int)(x2 - x1)); 
....................    dy = abs((signed int)(y2 - y1)); 
....................    x = x1; 
....................    y = y1; 
....................    c1 = -dx*x1 - dy*y1; 
....................    c2 = -dx*x2 - dy*y2; 
....................  
....................    if(x1 > x2) 
....................    { 
....................       addx = -1; 
....................       c1 = -dx*x2 - dy*y2; 
....................       c2 = -dx*x1 - dy*y1; 
....................    } 
....................    else 
....................       addx = 1; 
....................    if(y1 > y2) 
....................    { 
....................       addy = -1; 
....................       c1 = -dx*x2 - dy*y2; 
....................       c2 = -dx*x1 - dy*y1; 
....................    } 
....................    else 
....................       addy = 1; 
....................  
....................    if(dx >= dy) 
....................    { 
....................       P = 2*dy - dx; 
....................  
....................       for(i=0; i<=dx; ++i) 
....................       { 
....................          for(j=-(width/2); j<width/2+width%2; ++j) 
....................          { 
....................             if(dx*x+dy*(y+j)+c1 >= 0 && dx*x+dy*(y+j)+c2 <=0) 
....................                glcd_pixel(x, y+j, color); 
....................          } 
....................          if(P < 0) 
....................          { 
....................             P += 2*dy; 
....................             x += addx; 
....................          } 
....................          else 
....................          { 
....................             P += 2*dy - 2*dx; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       P = 2*dx - dy; 
....................  
....................       for(i=0; i<=dy; ++i) 
....................       { 
....................          if(P < 0) 
....................          { 
....................             P += 2*dx; 
....................             y += addy; 
....................          } 
....................          else 
....................          { 
....................             P += 2*dx - 2*dy; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................          for(j=-(width/2); j<width/2+width%2; ++j) 
....................          { 
....................             if(dx*x+dy*(y+j)+c1 >= 0 && dx*x+dy*(y+j)+c2 <=0) 
....................                glcd_pixel(x+j, y, color); 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... // Purpose:       Draw a circle on a graphic LCD 
.................... // Inputs:        (x,y) - the center of the circle 
.................... //                radius - the radius of the circle 
.................... //                fill - YES or NO 
.................... //                color - ON or OFF 
.................... void glcd_circle(int x, int y, int radius, int1 fill, int1 color) 
.................... { 
....................    signed int a, b, P; 
....................    a = 0; 
....................    b = radius; 
....................    P = 1 - radius; 
....................  
....................    do 
....................    { 
....................       if(fill) 
....................       { 
....................          glcd_line(x-a, y+b, x+a, y+b, color); 
....................          glcd_line(x-a, y-b, x+a, y-b, color); 
....................          glcd_line(x-b, y+a, x+b, y+a, color); 
....................          glcd_line(x-b, y-a, x+b, y-a, color); 
....................       } 
....................       else 
....................       { 
....................          glcd_pixel(a+x, b+y, color); 
....................          glcd_pixel(b+x, a+y, color); 
....................          glcd_pixel(x-a, b+y, color); 
....................          glcd_pixel(x-b, a+y, color); 
....................          glcd_pixel(b+x, y-a, color); 
....................          glcd_pixel(a+x, y-b, color); 
....................          glcd_pixel(x-a, y-b, color); 
....................          glcd_pixel(x-b, y-a, color); 
....................       } 
....................  
....................       if(P < 0) 
....................          P+= 3 + 2*a++; 
....................       else 
....................          P+= 5 + 2*(a++ - b--); 
....................     } while(a <= b); 
.................... } 
....................  
.................... // Purpose:       Write text on a graphic LCD 
.................... // Inputs:        (x,y) - The upper left coordinate of the first letter 
.................... //                textptr - A pointer to an array of text to display 
.................... //                size - The size of the text: 1 = 5x7, 2 = 10x14, ... 
.................... //                color - ON or OFF 
.................... void glcd_text57(int x, int y, char* textptr, int size, int1 color) 
.................... { 
....................    int i, j, k, l, m;                     // Loop counters 
....................    BYTE pixelData[5];                     // Stores character data 
....................  
....................    for(i=0; textptr[i] != '\0'; ++i, ++x) // Loop through the passed string 
....................    { 
....................       if(textptr[i] < 'S') // Checks if the letter is in the first text array 
....................          memcpy(pixelData, TEXT[textptr[i]-' '], 5); 
....................       else if(textptr[i] <= '~') // Check if the letter is in the second array 
....................          memcpy(pixelData, TEXT2[textptr[i]-'S'], 5); 
....................       else 
....................          memcpy(pixelData, TEXT[0], 5);   // Default to space 
....................  
....................       if(x+5*size >= GLCD_WIDTH)          // Performs character wrapping 
....................       { 
....................          x = 0;                           // Set x at far left position 
....................          y += 7*size + 1;                 // Set y at next position down 
....................       } 
....................       for(j=0; j<5; ++j, x+=size)         // Loop through character byte data 
....................       { 
....................          for(k=0; k<7*size; ++k)          // Loop through the vertical pixels 
....................          { 
....................             if(bit_test(pixelData[j], k)) // Check if the pixel should be set 
....................             { 
....................                for(l=0; l<size; ++l)      // The next two loops change the 
....................                {                          // character's size 
....................                   for(m=0; m<size; ++m) 
....................                   { 
....................                      glcd_pixel(x+m, y+k*size+l, color); // Draws the pixel 
....................                   } 
....................                } 
....................             } 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... // Purpose:       Fill the LCD screen with the passed in color. 
.................... //                Works much faster than drawing a rectangle to fill the screen. 
.................... // Inputs:        ON - turn all the pixels on 
.................... //                OFF - turn all the pixels off 
.................... // Dependencies:  glcd_writeByte() 
.................... void glcd_fillScreen(int1 color) 
.................... { 
....................    int i, j; 
....................  
....................    // Loop through the vertical pages 
....................    for(i = 0; i < 8; ++i) 
*
02B4:  CLRF   28
02B6:  MOVF   28,W
02B8:  SUBLW  07
02BA:  BNC   0324
....................    { 
....................       output_low(GLCD_DI);                      // Set for instruction 
02BC:  BCF    F93.2
02BE:  BCF    F8A.2
....................       glcd_writeByte(GLCD_CS1, 0b01000000);     // Set horizontal address to 0 
02C0:  MOVLW  08
02C2:  MOVWF  43
02C4:  MOVLW  40
02C6:  MOVWF  44
02C8:  RCALL  0280
....................       glcd_writeByte(GLCD_CS2, 0b01000000); 
02CA:  MOVLW  09
02CC:  MOVWF  43
02CE:  MOVLW  40
02D0:  MOVWF  44
02D2:  RCALL  0280
....................       glcd_writeByte(GLCD_CS1, i | 0b10111000); // Set page address 
02D4:  MOVF   28,W
02D6:  IORLW  B8
02D8:  MOVWF  2A
02DA:  MOVLW  08
02DC:  MOVWF  43
02DE:  MOVFF  2A,44
02E2:  RCALL  0280
....................       glcd_writeByte(GLCD_CS2, i | 0b10111000); 
02E4:  MOVF   28,W
02E6:  IORLW  B8
02E8:  MOVWF  2A
02EA:  MOVLW  09
02EC:  MOVWF  43
02EE:  MOVFF  2A,44
02F2:  RCALL  0280
....................       output_high(GLCD_DI);                     // Set for data 
02F4:  BCF    F93.2
02F6:  BSF    F8A.2
....................  
....................       // Loop through the horizontal sections 
....................       for(j = 0; j < 64; ++j) 
02F8:  CLRF   29
02FA:  MOVF   29,W
02FC:  SUBLW  3F
02FE:  BNC   0320
....................       { 
....................          glcd_writeByte(GLCD_CS1, 0xFF*color);  // Turn pixels on or off 
0300:  MOVF   27,W
0302:  MULLW  FF
0304:  MOVFF  FF3,44
0308:  MOVLW  08
030A:  MOVWF  43
030C:  RCALL  0280
....................          glcd_writeByte(GLCD_CS2, 0xFF*color);  // Turn pixels on or off 
030E:  MOVF   27,W
0310:  MULLW  FF
0312:  MOVFF  FF3,44
0316:  MOVLW  09
0318:  MOVWF  43
031A:  RCALL  0280
031C:  INCF   29,F
031E:  BRA    02FA
....................       } 
0320:  INCF   28,F
0322:  BRA    02B6
....................    } 
0324:  RETURN 0
.................... } 
....................  
.................... // Purpose:       Write a byte of data to the specified chip 
.................... // Inputs:        chipSelect - which chip to write the data to 
.................... //                data - the byte of data to write 
....................  
.................... void glcd_writeByte(char chip, BYTE data) 
.................... { 
....................    if(chip == GLCD_CS1)       // Choose which chip to write to 
*
0280:  MOVF   43,W
0282:  SUBLW  08
0284:  BNZ   028C
....................       output_high(GLCD_CS1); 
0286:  BCF    F93.0
0288:  BSF    F8A.0
028A:  BRA    0290
....................    else 
....................       output_high(GLCD_CS2); 
028C:  BCF    F93.1
028E:  BSF    F8A.1
....................  
....................    output_low(GLCD_RW);       // Set for writing 
0290:  BCF    F93.4
0292:  BCF    F8A.4
....................    output_d(data);            // Put the data on the port 
0294:  CLRF   F95
0296:  MOVFF  44,F8C
....................    output_high(GLCD_E);       // Pulse the enable pin 
029A:  BCF    F93.5
029C:  BSF    F8A.5
....................    delay_us(2); 
029E:  MOVLW  03
02A0:  MOVWF  00
02A2:  DECFSZ 00,F
02A4:  BRA    02A2
....................    output_low(GLCD_E); 
02A6:  BCF    F93.5
02A8:  BCF    F8A.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
02AA:  BCF    F93.0
02AC:  BCF    F8A.0
....................    output_low(GLCD_CS2); 
02AE:  BCF    F93.1
02B0:  BCF    F8A.1
02B2:  RETURN 0
.................... } 
....................  
....................  
.................... // Purpose:       Reads a byte of data from the specified chip 
.................... // Ouputs:        A byte of data read from the chip 
.................... BYTE glcd_readByte(BYTE chip) 
.................... { 
....................    BYTE data;                 // Stores the data read from the LCD 
....................    if(chip == GLCD_CS1)       // Choose which chip to read from 
*
03F6:  MOVF   42,W
03F8:  SUBLW  08
03FA:  BNZ   0402
....................       output_high(GLCD_CS1); 
03FC:  BCF    F93.0
03FE:  BSF    F8A.0
0400:  BRA    0406
....................    else 
....................       output_high(GLCD_CS2); 
0402:  BCF    F93.1
0404:  BSF    F8A.1
....................  
....................    input_d();                 // Set port d to input 
0406:  SETF   F95
....................    output_high(GLCD_RW);      // Set for reading 
0408:  BCF    F93.4
040A:  BSF    F8A.4
....................    output_high(GLCD_E);       // Pulse the enable pin 
040C:  BCF    F93.5
040E:  BSF    F8A.5
....................    delay_us(2); 
0410:  MOVLW  03
0412:  MOVWF  00
0414:  DECFSZ 00,F
0416:  BRA    0414
....................    output_low(GLCD_E); 
0418:  BCF    F93.5
041A:  BCF    F8A.5
....................    delay_us(2); 
041C:  MOVLW  03
041E:  MOVWF  00
0420:  DECFSZ 00,F
0422:  BRA    0420
....................    output_high(GLCD_E);       // Pulse the enable pin 
0424:  BCF    F93.5
0426:  BSF    F8A.5
....................    delay_us(2); 
0428:  MOVLW  03
042A:  MOVWF  00
042C:  DECFSZ 00,F
042E:  BRA    042C
....................    data = input_d();          // Get the data from the display's output register 
0430:  SETF   F95
0432:  MOVFF  F83,43
....................    output_low(GLCD_E); 
0436:  BCF    F93.5
0438:  BCF    F8A.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
043A:  BCF    F93.0
043C:  BCF    F8A.0
....................    output_low(GLCD_CS2); 
043E:  BCF    F93.1
0440:  BCF    F8A.1
....................    return data;               // Return the read data 
0442:  MOVFF  43,01
0446:  GOTO   0494 (RETURN)
.................... } 
....................  
.................... #endif 
....................  
.................... #define CNT_MAX 24 
.................... #define POINT_MAX 102 
.................... #define INICIO_X 0 
.................... #define FIM_X 102 
.................... #define INICIO_Y 0 
.................... #define FIM_Y 62 
.................... #define MEIO_X (INICIO_X+FIM_X)/2 
.................... #define MEIO_Y (INICIO_Y+FIM_Y)/2 
.................... signed int32 tensao, val; 
.................... int8 cnt=0; 
.................... int8 ponto=POINT_MAX; 
.................... #INT_TIMER2 
.................... void timer2_isr() 
.................... { 
....................    cnt=(cnt==1) ? 0 : cnt+1; 
*
01E8:  DECFSZ 22,W
01EA:  BRA    01F0
01EC:  MOVLW  00
01EE:  BRA    01F4
01F0:  MOVLW  01
01F2:  ADDWF  22,W
01F4:  MOVWF  22
....................    tensao=read_adc(); 
01F6:  BSF    FC2.1
01F8:  BTFSC  FC2.1
01FA:  BRA    01F8
01FC:  CLRF   02
01FE:  CLRF   03
0200:  MOVFF  03,1D
0204:  MOVFF  02,1C
0208:  MOVFF  FC4,1B
020C:  MOVFF  FC3,1A
....................    tensao=tensao-512; 
0210:  MOVLW  00
0212:  SUBWF  1A,F
0214:  MOVLW  02
0216:  SUBWFB 1B,F
0218:  MOVLW  00
021A:  SUBWFB 1C,F
021C:  SUBWFB 1D,F
....................    val=(tensao*20000)/1023; 
021E:  MOVFF  1D,48
0222:  MOVFF  1C,47
0226:  MOVFF  1B,46
022A:  MOVFF  1A,45
022E:  CLRF   4C
0230:  CLRF   4B
0232:  MOVLW  4E
0234:  MOVWF  4A
0236:  MOVLW  20
0238:  MOVWF  49
023A:  BRA    00AE
023C:  MOVFF  03,48
0240:  MOVFF  02,47
0244:  MOVFF  01,46
0248:  MOVFF  00,45
024C:  BCF    FD8.1
024E:  MOVFF  03,4C
0252:  MOVFF  02,4B
0256:  MOVFF  01,4A
025A:  MOVFF  00,49
025E:  CLRF   50
0260:  CLRF   4F
0262:  MOVLW  03
0264:  MOVWF  4E
0266:  SETF   4D
0268:  RCALL  0104
026A:  MOVFF  03,21
026E:  MOVFF  02,20
0272:  MOVFF  01,1F
0276:  MOVFF  00,1E
....................    /*if(tensao>512) 
....................    tensao=tensao-512; 
....................    val=(tensao*20000)/1023;*/ 
027A:  BCF    F9E.1
027C:  GOTO   0060
.................... } 
....................  
.................... void representacao(signed int32 value, int8 point) 
.................... {    
....................     if(value<0) 
*
0836:  BTFSS  27.7
0838:  BRA    08EC
....................     { 
....................     value=(value%10000)/1000; 
083A:  BSF    FD8.1
083C:  CLRF   FEA
083E:  MOVLW  29
0840:  MOVWF  FE9
0842:  CLRF   19
0844:  BTFSC  FF2.7
0846:  BSF    19.7
0848:  BCF    FF2.7
084A:  MOVFF  27,4C
084E:  MOVFF  26,4B
0852:  MOVFF  25,4A
0856:  MOVFF  24,49
085A:  CLRF   50
085C:  CLRF   4F
085E:  MOVLW  27
0860:  MOVWF  4E
0862:  MOVLW  10
0864:  MOVWF  4D
0866:  RCALL  0104
0868:  BTFSC  19.7
086A:  BSF    FF2.7
086C:  MOVFF  2C,30
0870:  MOVFF  2B,2F
0874:  MOVFF  2A,2E
0878:  MOVFF  29,2D
087C:  MOVFF  FEA,32
0880:  MOVFF  FE9,31
0884:  BCF    FD8.1
0886:  CLRF   19
0888:  BTFSC  FF2.7
088A:  BSF    19.7
088C:  BCF    FF2.7
088E:  MOVFF  2C,4C
0892:  MOVFF  2B,4B
0896:  MOVFF  2A,4A
089A:  MOVFF  29,49
089E:  CLRF   50
08A0:  CLRF   4F
08A2:  MOVLW  03
08A4:  MOVWF  4E
08A6:  MOVLW  E8
08A8:  MOVWF  4D
08AA:  RCALL  0104
08AC:  BTFSC  19.7
08AE:  BSF    FF2.7
08B0:  MOVFF  32,FEA
08B4:  MOVFF  31,FE9
08B8:  MOVFF  03,27
08BC:  MOVFF  02,26
08C0:  MOVFF  01,25
08C4:  MOVFF  00,24
....................     glcd_pixel(INICIO_X+point,MEIO_Y+value,off); 
08C8:  MOVLW  1F
08CA:  ADDWF  24,W
08CC:  MOVWF  29
08CE:  MOVLW  00
08D0:  ADDWFC 25,W
08D2:  MOVWF  2A
08D4:  MOVLW  00
08D6:  ADDWFC 26,W
08D8:  MOVWF  2B
08DA:  MOVLW  00
08DC:  ADDWFC 27,W
08DE:  MOVWF  2C
08E0:  MOVFF  28,3D
08E4:  MOVFF  29,3E
08E8:  CLRF   3F
08EA:  RCALL  044A
....................     } 
....................     if(value>=0) 
08EC:  BTFSC  27.7
08EE:  BRA    09A8
....................     { 
....................     value=(value%10000)/1000; 
08F0:  BSF    FD8.1
08F2:  CLRF   FEA
08F4:  MOVLW  29
08F6:  MOVWF  FE9
08F8:  CLRF   19
08FA:  BTFSC  FF2.7
08FC:  BSF    19.7
08FE:  BCF    FF2.7
0900:  MOVFF  27,4C
0904:  MOVFF  26,4B
0908:  MOVFF  25,4A
090C:  MOVFF  24,49
0910:  CLRF   50
0912:  CLRF   4F
0914:  MOVLW  27
0916:  MOVWF  4E
0918:  MOVLW  10
091A:  MOVWF  4D
091C:  CALL   0104
0920:  BTFSC  19.7
0922:  BSF    FF2.7
0924:  MOVFF  2C,30
0928:  MOVFF  2B,2F
092C:  MOVFF  2A,2E
0930:  MOVFF  29,2D
0934:  MOVFF  FEA,32
0938:  MOVFF  FE9,31
093C:  BCF    FD8.1
093E:  CLRF   19
0940:  BTFSC  FF2.7
0942:  BSF    19.7
0944:  BCF    FF2.7
0946:  MOVFF  2C,4C
094A:  MOVFF  2B,4B
094E:  MOVFF  2A,4A
0952:  MOVFF  29,49
0956:  CLRF   50
0958:  CLRF   4F
095A:  MOVLW  03
095C:  MOVWF  4E
095E:  MOVLW  E8
0960:  MOVWF  4D
0962:  CALL   0104
0966:  BTFSC  19.7
0968:  BSF    FF2.7
096A:  MOVFF  32,FEA
096E:  MOVFF  31,FE9
0972:  MOVFF  03,27
0976:  MOVFF  02,26
097A:  MOVFF  01,25
097E:  MOVFF  00,24
....................     glcd_pixel(INICIO_X+point,MEIO_Y-value,off); 
0982:  MOVLW  1F
0984:  BSF    FD8.0
0986:  SUBFWB 24,W
0988:  MOVWF  29
098A:  MOVLW  00
098C:  SUBFWB 25,W
098E:  MOVWF  2A
0990:  MOVLW  00
0992:  SUBFWB 26,W
0994:  MOVWF  2B
0996:  MOVLW  00
0998:  SUBFWB 27,W
099A:  MOVWF  2C
099C:  MOVFF  28,3D
09A0:  MOVFF  29,3E
09A4:  CLRF   3F
09A6:  RCALL  044A
....................     } 
09A8:  RETURN 0
.................... } 
....................  
.................... void faz_indicador(int8 x0, int8 y0) 
.................... { 
....................    int8 a,b,c; 
....................    c=0; 
....................    for(a=y0;a<=y0+2;a--) 
....................    { 
....................       for(b=x0;b<=x0+4-2*c;b++) 
....................       { 
....................       glcd_pixel(b,a,ON); 
....................       } 
....................       c++; 
....................       x0++; 
....................    } 
.................... } 
....................  
.................... void desfaz_indicador(int8 x0, int8 y0) 
.................... { 
....................    int8 a,b,c; 
....................    c=0; 
....................    for(a=y0;a<=y0+2;a--) 
....................    { 
....................       for(b=x0;b<=x0+4-2*c;b++) 
....................       { 
....................       glcd_pixel(b,a,OFF); 
....................       } 
....................       c++; 
....................       x0++; 
....................    } 
.................... } 
....................  
.................... void quadro_osc(int8 state, int8 distance) 
.................... { 
....................    int8 i; 
....................    glcd_fillscreen(off); 
*
0704:  CLRF   27
0706:  RCALL  02B4
....................    glcd_rect(INICIO_X,INICIO_Y,FIM_X,FIM_Y,state,state); // faz retangulo delimitador 
0708:  CLRF   27
070A:  CLRF   28
070C:  MOVLW  66
070E:  MOVWF  29
0710:  MOVLW  3E
0712:  MOVWF  2A
0714:  MOVFF  24,2B
0718:  MOVFF  24,2C
071C:  BRA    066A
....................    glcd_line(MEIO_X,INICIO_Y,MEIO_X,FIM_Y,~state); // faz linha vertical principal 
071E:  MOVFF  24,27
0722:  COMF   27,F
0724:  MOVLW  33
0726:  MOVWF  2F
0728:  CLRF   30
072A:  MOVWF  31
072C:  MOVLW  3E
072E:  MOVWF  32
0730:  MOVFF  27,33
0734:  RCALL  04F6
....................    for(i=MEIO_X;i<=FIM_X;i=i+distance){ 
0736:  MOVLW  33
0738:  MOVWF  26
073A:  MOVF   26,W
073C:  SUBLW  66
073E:  BNC   076E
....................    glcd_pixel(i,MEIO_Y-1,~state); // faz linha horizontal secundária inferior direita 
0740:  MOVFF  24,27
0744:  COMF   27,F
0746:  MOVFF  26,3D
074A:  MOVLW  1E
074C:  MOVWF  3E
074E:  MOVFF  27,3F
0752:  RCALL  044A
....................    glcd_pixel(i,MEIO_Y+1,~state); // faz linha horizontal secundária superior direita 
0754:  MOVFF  24,27
0758:  COMF   27,F
075A:  MOVFF  26,3D
075E:  MOVLW  20
0760:  MOVWF  3E
0762:  MOVFF  27,3F
0766:  RCALL  044A
0768:  MOVF   25,W
076A:  ADDWF  26,F
076C:  BRA    073A
....................    } 
....................    for(i=MEIO_X;i<=FIM_X;i=i-distance){ 
076E:  MOVLW  33
0770:  MOVWF  26
0772:  MOVF   26,W
0774:  SUBLW  66
0776:  BNC   07A6
....................    glcd_pixel(i,MEIO_Y-1,~state); // faz linha horizontal secundária inferior esquerda 
0778:  MOVFF  24,27
077C:  COMF   27,F
077E:  MOVFF  26,3D
0782:  MOVLW  1E
0784:  MOVWF  3E
0786:  MOVFF  27,3F
078A:  RCALL  044A
....................    glcd_pixel(i,MEIO_Y+1,~state); // faz linha horizontal secundária superior esquerda 
078C:  MOVFF  24,27
0790:  COMF   27,F
0792:  MOVFF  26,3D
0796:  MOVLW  20
0798:  MOVWF  3E
079A:  MOVFF  27,3F
079E:  RCALL  044A
07A0:  MOVF   25,W
07A2:  SUBWF  26,F
07A4:  BRA    0772
....................    } 
....................    for(i=MEIO_Y;i<=FIM_Y;i=i+(distance+2)){ 
07A6:  MOVLW  1F
07A8:  MOVWF  26
07AA:  MOVF   26,W
07AC:  SUBLW  3E
07AE:  BNC   07E0
....................    glcd_pixel(MEIO_X-1,i,~state); // faz linha vertical secundária esquerda inferior 
07B0:  MOVFF  24,27
07B4:  COMF   27,F
07B6:  MOVLW  32
07B8:  MOVWF  3D
07BA:  MOVFF  26,3E
07BE:  MOVFF  27,3F
07C2:  RCALL  044A
....................    glcd_pixel(MEIO_X+1,i,~state); // faz linha vertical secundária direita inferior 
07C4:  MOVFF  24,27
07C8:  COMF   27,F
07CA:  MOVLW  34
07CC:  MOVWF  3D
07CE:  MOVFF  26,3E
07D2:  MOVFF  27,3F
07D6:  RCALL  044A
07D8:  MOVLW  02
07DA:  ADDWF  25,W
07DC:  ADDWF  26,F
07DE:  BRA    07AA
....................    } 
....................    for(i=MEIO_Y;i<=FIM_Y;i=i-(distance+2)){ 
07E0:  MOVLW  1F
07E2:  MOVWF  26
07E4:  MOVF   26,W
07E6:  SUBLW  3E
07E8:  BNC   081A
....................    glcd_pixel(MEIO_X-1,i,~state); // faz linha vertical secundária esquerda superior 
07EA:  MOVFF  24,27
07EE:  COMF   27,F
07F0:  MOVLW  32
07F2:  MOVWF  3D
07F4:  MOVFF  26,3E
07F8:  MOVFF  27,3F
07FC:  RCALL  044A
....................    glcd_pixel(MEIO_X+1,i,~state); // faz linha vertical secundária direita superior 
07FE:  MOVFF  24,27
0802:  COMF   27,F
0804:  MOVLW  34
0806:  MOVWF  3D
0808:  MOVFF  26,3E
080C:  MOVFF  27,3F
0810:  RCALL  044A
0812:  MOVLW  02
0814:  ADDWF  25,W
0816:  SUBWF  26,F
0818:  BRA    07E4
....................    } 
....................    glcd_line(INICIO_X,MEIO_Y,FIM_X,MEIO_Y,~state); // faz linha horizontal principal 
081A:  MOVFF  24,27
081E:  COMF   27,F
0820:  CLRF   2F
0822:  MOVLW  1F
0824:  MOVWF  30
0826:  MOVLW  66
0828:  MOVWF  31
082A:  MOVLW  1F
082C:  MOVWF  32
082E:  MOVFF  27,33
0832:  RCALL  04F6
0834:  RETURN 0
.................... } 
....................     
.................... void main() 
*
09AA:  CLRF   FF8
09AC:  BCF    FD0.7
09AE:  BSF    07.7
09B0:  CLRF   22
09B2:  MOVLW  66
09B4:  MOVWF  23
09B6:  MOVF   FC1,W
09B8:  ANDLW  C0
09BA:  IORLW  0F
09BC:  MOVWF  FC1
09BE:  MOVLW  07
09C0:  MOVWF  FB4
.................... { 
....................    set_tris_a(0xff); 
09C2:  MOVLW  FF
09C4:  MOVWF  F92
....................    setup_timer_2(T2_DIV_BY_16,75,10);//(.,75,10) 
09C6:  MOVLW  48
09C8:  IORLW  06
09CA:  MOVWF  FCA
09CC:  MOVLW  4B
09CE:  MOVWF  FCB
....................    setup_adc_ports(AN0|VREF_VREF); // seleciona canal de para leitura ADC 
09D0:  MOVF   FC1,W
09D2:  ANDLW  C0
09D4:  IORLW  3E
09D6:  MOVWF  FC1
....................    set_adc_channel(0);           // e referencia para leitura VSS_VDD 
09D8:  MOVLW  00
09DA:  MOVWF  01
09DC:  MOVF   FC2,W
09DE:  ANDLW  C3
09E0:  IORWF  01,W
09E2:  MOVWF  FC2
....................    delay_us(10); 
09E4:  MOVLW  10
09E6:  MOVWF  00
09E8:  DECFSZ 00,F
09EA:  BRA    09E8
09EC:  NOP   
....................    setup_adc(ADC_CLOCK_INTERNAL);// operação com clock interno 
09EE:  MOVF   FC0,W
09F0:  ANDLW  C0
09F2:  IORLW  07
09F4:  MOVWF  FC0
09F6:  BSF    FC0.7
09F8:  BSF    FC2.0
....................    glcd_init(on); 
09FA:  MOVLW  01
09FC:  MOVWF  24
09FE:  BRA    0326
....................    quadro_osc(on,5); 
0A00:  MOVLW  01
0A02:  MOVWF  24
0A04:  MOVLW  05
0A06:  MOVWF  25
0A08:  RCALL  0704
....................    enable_interrupts(INT_TIMER2); 
0A0A:  BSF    F9D.1
....................    enable_interrupts(GLOBAL);                     
0A0C:  MOVLW  C0
0A0E:  IORWF  FF2,F
....................           
....................    while(TRUE) 
....................    { 
....................  
....................       if(cnt==0) 
0A10:  MOVF   22,F
0A12:  BNZ   0A5C
....................       {  
....................          if(ponto==POINT_MAX) 
0A14:  MOVF   23,W
0A16:  SUBLW  66
0A18:  BNZ   0A3C
....................          { 
....................          representacao(val,ponto); 
0A1A:  MOVFF  21,27
0A1E:  MOVFF  20,26
0A22:  MOVFF  1F,25
0A26:  MOVFF  1E,24
0A2A:  MOVFF  23,28
0A2E:  RCALL  0836
....................          quadro_osc(on,5); 
0A30:  MOVLW  01
0A32:  MOVWF  24
0A34:  MOVLW  05
0A36:  MOVWF  25
0A38:  RCALL  0704
....................          ponto=0; 
0A3A:  CLRF   23
....................          } 
....................          if(ponto!=POINT_MAX) 
0A3C:  MOVF   23,W
0A3E:  SUBLW  66
0A40:  BZ    0A5C
....................          { 
....................          representacao(val,ponto); 
0A42:  MOVFF  21,27
0A46:  MOVFF  20,26
0A4A:  MOVFF  1F,25
0A4E:  MOVFF  1E,24
0A52:  MOVFF  23,28
0A56:  RCALL  0836
....................          ponto=ponto+1; 
0A58:  MOVLW  01
0A5A:  ADDWF  23,F
....................          } 
....................       } 
0A5C:  BRA    0A10
....................    } 
.................... } 
0A5E:  SLEEP 

Configuration Fuses:
   Word  1: CC04   PLL5 CPUDIV1 NOUSBDIV HS FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
